<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Santorini</title>

    <!-- iOS app installation headers -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Santorini">

    <style>
        * {
            user-select: none;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(ellipse at center, #4A90E2 0%, #1E3A5F 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0,0,0,0.6) 100%);
            pointer-events: none;
            z-index: 1;
        }

        .game-board {
            position: relative;
            z-index: 2;
            transform-origin: top left;
        }

        .game-container {
            background: linear-gradient(135deg, #2E5A8C 0%, #1E3A5F 100%);
            border-radius: 14px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            position: relative;
        }

        .game-header {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 40px;
        }

        .player-info {
            background: rgba(30, 58, 95, 0.6);
            border-radius: 10px;
            padding: 20px;
            color: white;
            min-width: 150px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .player-info.active {
            border-color: #FFD700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
        }

        .player-name {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .player-color {
            font-size: 14px;
            opacity: 0.8;
        }

        .player-status {
            font-size: 14px;
            font-weight: 600;
            margin-top: 12px;
            color: #FFD700;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .player-info.active .player-status {
            opacity: 1;
        }

        .worker-preview {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin: 5px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            display: inline-block;
        }

        .worker-preview.blue {
            background: radial-gradient(circle at 30% 30%, #4A90E2, #2E5A8C);
        }

        .worker-preview.orange {
            background: radial-gradient(circle at 30% 30%, #FFA500, #FF8C00);
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(5, 80px);
            grid-template-rows: repeat(5, 80px);
            gap: 6px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 12px;
            box-shadow:
                inset 0 4px 12px rgba(0,0,0,0.5),
                0 8px 24px rgba(0,0,0,0.3);
        }

        .grid-cell {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #E8D4A0 0%, #C4A56E 100%);
            border-radius: 6px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow:
                0 2px 4px rgba(0,0,0,0.3),
                inset 0 1px 2px rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .grid-cell:hover {
            transform: translateY(-2px);
            box-shadow:
                0 4px 8px rgba(0,0,0,0.4),
                inset 0 1px 2px rgba(255,255,255,0.2);
        }

        .grid-cell.valid-move {
            box-shadow: 0 0 0 3px #10b981, 0 0 20px rgba(16, 185, 129, 0.6);
        }

        .grid-cell.valid-build {
            box-shadow: 0 0 0 3px #f59e0b, 0 0 20px rgba(245, 158, 11, 0.6);
        }

        .building-stack {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        /* Top-down 3D view - each level is a layered square */
        .building-level-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .building-level {
            position: absolute;
            background: linear-gradient(135deg, #ffffff 0%, #e8e8e8 100%);
            border-radius: 3px;
            box-shadow:
                0 2px 4px rgba(0,0,0,0.2),
                inset -1px -1px 3px rgba(0,0,0,0.1),
                inset 1px 1px 3px rgba(255,255,255,0.5);
            border: 1px solid rgba(0,0,0,0.15);
        }

        .building-level.level-1 {
            width: 70%;
            height: 70%;
            background: linear-gradient(135deg, #ffffff 0%, #e0e0e0 100%);
            z-index: 1;
        }

        .building-level.level-2 {
            width: 55%;
            height: 55%;
            background: linear-gradient(135deg, #f5f5f5 0%, #d5d5d5 100%);
            box-shadow:
                0 3px 6px rgba(0,0,0,0.25),
                inset -1px -1px 3px rgba(0,0,0,0.15),
                inset 1px 1px 3px rgba(255,255,255,0.5);
            z-index: 2;
        }

        .building-level.level-3 {
            width: 40%;
            height: 40%;
            background: linear-gradient(135deg, #eeeeee 0%, #cacaca 100%);
            box-shadow:
                0 4px 8px rgba(0,0,0,0.3),
                inset -1px -1px 4px rgba(0,0,0,0.2),
                inset 1px 1px 4px rgba(255,255,255,0.5);
            z-index: 3;
        }

        .dome {
            width: 35%;
            height: 35%;
            background:
                radial-gradient(ellipse at 30% 30%, rgba(255,255,255,0.8) 0%, transparent 20%),
                radial-gradient(ellipse at 50% 50%, #A8D5F7 0%, #5AA3F0 40%, #2E7ABF 100%);
            border-radius: 50%;
            position: absolute;
            box-shadow:
                0 6px 14px rgba(0,0,0,0.5),
                inset -3px -3px 8px rgba(0,0,0,0.3),
                inset 3px 3px 8px rgba(255,255,255,0.5);
            border: 2px solid #1E5A8F;
            z-index: 4;
            position: relative;
            overflow: hidden;
        }

        .dome::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                linear-gradient(135deg,
                    transparent 0%,
                    transparent 40%,
                    rgba(30, 90, 143, 0.3) 45%,
                    transparent 50%,
                    transparent 100%),
                linear-gradient(45deg,
                    rgba(30, 90, 143, 0.3) 0%,
                    transparent 30%,
                    transparent 70%,
                    rgba(30, 90, 143, 0.3) 100%);
            border-radius: 50%;
        }

        .dome::after {
            content: '';
            position: absolute;
            top: 15%;
            left: 20%;
            width: 35%;
            height: 35%;
            background: radial-gradient(circle, rgba(255,255,255,0.7) 0%, transparent 60%);
            border-radius: 50%;
            filter: blur(3px);
        }

        .worker {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow:
                0 6px 16px rgba(0,0,0,0.6),
                0 2px 4px rgba(0,0,0,0.4),
                inset -2px -2px 6px rgba(0,0,0,0.3),
                inset 2px 2px 6px rgba(255,255,255,0.4);
            cursor: grab;
            z-index: 100;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .worker.blue {
            background: radial-gradient(circle at 35% 35%, #5AA3F0, #2E5A8C);
            border: 2px solid #1E3A5F;
        }

        .worker.orange {
            background: radial-gradient(circle at 35% 35%, #FFB732, #E67E00);
            border: 2px solid #C86700;
        }

        .worker.dragging {
            position: fixed !important;
            z-index: 1000 !important;
            cursor: grabbing;
            box-shadow: 0 12px 32px rgba(0,0,0,0.7);
            pointer-events: none;
            opacity: 0.9;
        }

        .worker-ghost {
            opacity: 0.3;
        }

        .worker.inactive {
            cursor: default;
        }

        .game-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 30px;
        }

        .game-button {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 25%, #1a1a1a 50%, #2d2d2d 75%, #1a1a1a 100%);
            background-size: 200% 200%;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 600;
            color: white;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .game-button:hover {
            background: linear-gradient(135deg, #202020 0%, #333333 25%, #202020 50%, #333333 75%, #202020 100%);
            background-size: 200% 200%;
        }

        .game-button:active {
            transform: translateY(1px);
        }

        .victory-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 9998;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .victory-text {
            font-size: 80px;
            font-weight: 900;
            color: #FFD700;
            text-shadow:
                0 0 20px rgba(255, 215, 0, 0.8),
                0 0 40px rgba(255, 215, 0, 0.6),
                0 0 60px rgba(255, 215, 0, 0.4),
                4px 4px 8px rgba(0, 0, 0, 0.8);
            text-align: center;
            animation: victory-glow 2s ease-in-out infinite alternate;
            letter-spacing: 8px;
            text-transform: uppercase;
            margin-bottom: 30px;
        }

        @keyframes victory-glow {
            from {
                text-shadow:
                    0 0 20px rgba(255, 215, 0, 0.8),
                    0 0 40px rgba(255, 215, 0, 0.6),
                    0 0 60px rgba(255, 215, 0, 0.4),
                    4px 4px 8px rgba(0, 0, 0, 0.8);
            }
            to {
                text-shadow:
                    0 0 30px rgba(255, 215, 0, 1),
                    0 0 60px rgba(255, 215, 0, 0.8),
                    0 0 90px rgba(255, 215, 0, 0.6),
                    4px 4px 8px rgba(0, 0, 0, 0.8);
            }
        }

        .victory-subtext {
            font-size: 32px;
            font-weight: 700;
            color: white;
            text-shadow:
                0 0 10px rgba(255, 255, 255, 0.8),
                2px 2px 4px rgba(0, 0, 0, 0.8);
            text-align: center;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 16px;
            border-radius: 0 50% 50% 50%;
            animation: confetti-fall 3s ease-in forwards;
            transform: rotate(45deg);
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-20vh) translateX(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(110vh) translateX(calc(var(--drift-x) * 3)) rotate(810deg);
                opacity: 0;
            }
        }

        .info-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            color: white;
            border: none;
            font-size: 24px;
            font-style: italic;
            font-family: Georgia, serif;
            cursor: pointer;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            transition: all 0.2s ease;
        }

        .info-button:hover {
            text-shadow: 2px 2px 8px rgba(255, 215, 0, 0.6);
            color: #FFD700;
        }

        .info-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        .info-panel {
            background: linear-gradient(135deg, #2E5A8C 0%, #1E3A5F 100%);
            border-radius: 14px;
            padding: 40px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            color: white;
        }

        .info-panel h2 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #FFD700;
            font-size: 32px;
            text-align: center;
        }

        .info-panel h3 {
            margin-top: 24px;
            margin-bottom: 12px;
            color: #FFD700;
            font-size: 20px;
        }

        .info-panel p {
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .info-panel ul {
            margin: 12px 0;
            padding-left: 24px;
        }

        .info-panel li {
            margin-bottom: 8px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="game-board">
        <div class="game-container">
            <button class="info-button" id="info-button">i</button>

            <!-- Game Header with Player Info and Board -->
            <div class="game-header">
                <div class="player-info" id="player-1-info">
                    <div class="player-name">Player 1</div>
                    <div>
                        <div class="worker-preview" id="player-1-preview-1"></div>
                        <div class="worker-preview" id="player-1-preview-2"></div>
                    </div>
                    <div class="player-color" id="player-1-color"></div>
                    <div class="player-status" id="player-1-status"></div>
                </div>

                <!-- Game Board Grid (5 rows x 5 columns) -->
                <div class="grid-container" id="grid-container">
                    <!-- Grid cells will be generated by JavaScript -->
                </div>

                <div class="player-info" id="player-2-info">
                    <div class="player-name">Player 2</div>
                    <div>
                        <div class="worker-preview" id="player-2-preview-1"></div>
                        <div class="worker-preview" id="player-2-preview-2"></div>
                    </div>
                    <div class="player-color" id="player-2-color"></div>
                    <div class="player-status" id="player-2-status"></div>
                </div>
            </div>

            <!-- Game Controls -->
            <div class="game-controls">
                <button class="game-button" id="new-game">New Game</button>
                <button class="game-button" id="back-button">Exit</button>
            </div>
        </div>
    </div>

    <script>
        // Game configuration
        const GRID_SIZE = 5;

        // Game state
        let gameState = {
            board: [], // 2D array tracking building heights (0-4, where 4 = dome)
            workers: {
                player1: [],
                player2: []
            },
            player1Color: 'blue',
            player2Color: 'orange',
            currentPlayer: 1,
            gamePhase: 'setup', // 'setup', 'move', or 'build'
            setupPhase: 'player1-worker1', // Track which worker is being placed
            selectedWorker: null,
            gameOver: false,
            winner: null
        };

        let dragState = {
            isDragging: false,
            dragClone: null,
            dragOffsetX: 0,
            dragOffsetY: 0,
            originalWorker: null,
            workerId: null
        };

        let currentBoardScale = 1;

        // Utility: Debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Initialize game
        function initGame() {
            // Randomly assign colors
            if (Math.random() < 0.5) {
                gameState.player1Color = 'orange';
                gameState.player2Color = 'blue';
            } else {
                gameState.player1Color = 'blue';
                gameState.player2Color = 'orange';
            }

            // Update player info display
            document.getElementById('player-1-preview-1').className = `worker-preview ${gameState.player1Color}`;
            document.getElementById('player-1-preview-2').className = `worker-preview ${gameState.player1Color}`;
            document.getElementById('player-2-preview-1').className = `worker-preview ${gameState.player2Color}`;
            document.getElementById('player-2-preview-2').className = `worker-preview ${gameState.player2Color}`;
            document.getElementById('player-1-color').textContent = gameState.player1Color.toUpperCase();
            document.getElementById('player-2-color').textContent = gameState.player2Color.toUpperCase();

            // Initialize board (all tiles at level 0)
            gameState.board = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));

            // Create grid cells
            const gridContainer = document.getElementById('grid-container');
            gridContainer.innerHTML = '';

            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener('click', () => handleCellClick(row, col));
                    gridContainer.appendChild(cell);
                }
            }

            // Reset game state
            gameState.workers.player1 = [];
            gameState.workers.player2 = [];
            gameState.currentPlayer = 1;
            gameState.gamePhase = 'setup';
            gameState.setupPhase = 'player1-worker1';
            gameState.selectedWorker = null;
            gameState.gameOver = false;
            gameState.winner = null;

            // Render initial state
            renderGame();
            updateStatus();
            setupDragAndDrop();
        }

        // Render game state
        function renderGame() {
            const gridContainer = document.getElementById('grid-container');
            const cells = gridContainer.querySelectorAll('.grid-cell');

            // Update cells
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);

                // Remove existing workers and buildings
                cell.querySelectorAll('.worker').forEach(w => w.remove());
                cell.querySelectorAll('.building-stack').forEach(b => b.remove());

                // Add building stack
                const height = gameState.board[row][col];
                if (height > 0) {
                    const stack = createBuildingStack(height);
                    cell.appendChild(stack);
                }

                // Clear highlighting
                cell.classList.remove('valid-move', 'valid-build');
            });

            // Add workers
            const allWorkers = [
                ...gameState.workers.player1.map(w => ({ ...w, player: 1, color: gameState.player1Color })),
                ...gameState.workers.player2.map(w => ({ ...w, player: 2, color: gameState.player2Color }))
            ];

            allWorkers.forEach(worker => {
                const cell = gridContainer.querySelector(`[data-row="${worker.row}"][data-col="${worker.col}"]`);
                if (cell) {
                    const workerEl = createWorker(worker.id, worker.color, worker.player);
                    cell.appendChild(workerEl);
                }
            });

            // Update player info highlighting
            document.getElementById('player-1-info').classList.toggle('active', gameState.currentPlayer === 1 && !gameState.gameOver);
            document.getElementById('player-2-info').classList.toggle('active', gameState.currentPlayer === 2 && !gameState.gameOver);
        }

        // Create building stack (top-down view)
        function createBuildingStack(height) {
            const stack = document.createElement('div');
            stack.className = 'building-stack';

            const container = document.createElement('div');
            container.className = 'building-level-container';

            // Add levels from bottom to top (rendered back to front)
            for (let i = 1; i <= Math.min(height, 3); i++) {
                const level = document.createElement('div');
                level.className = `building-level level-${i}`;
                container.appendChild(level);
            }

            if (height === 4) {
                const dome = document.createElement('div');
                dome.className = 'dome';
                container.appendChild(dome);
            }

            stack.appendChild(container);
            return stack;
        }

        // Create worker element
        function createWorker(id, color, player) {
            const worker = document.createElement('div');
            worker.className = `worker ${color}`;
            worker.dataset.id = id;
            worker.dataset.player = player;

            // Only current player's workers are draggable during move phase
            if (gameState.gamePhase === 'setup' || player !== gameState.currentPlayer || gameState.gamePhase !== 'move' || gameState.gameOver) {
                worker.classList.add('inactive');
            }

            return worker;
        }

        // Set up drag and drop
        function setupDragAndDrop() {
            const gridContainer = document.getElementById('grid-container');

            // Mouse events
            gridContainer.addEventListener('mousedown', handleDragStart, false);
            document.addEventListener('mousemove', handleDragMove, false);
            document.addEventListener('mouseup', handleDragEnd, false);

            // Touch events
            gridContainer.addEventListener('touchstart', handleDragStart, { passive: false });
            document.addEventListener('touchmove', handleDragMove, { passive: false });
            document.addEventListener('touchend', handleDragEnd, false);
        }

        // Handle drag start
        function handleDragStart(e) {
            if (gameState.gameOver || gameState.gamePhase !== 'move' || gameState.gamePhase === 'setup') return;

            const touch = e.type.startsWith('touch') ? e.touches[0] : e;
            const target = e.type.startsWith('touch') ?
                document.elementFromPoint(touch.clientX, touch.clientY) : e.target;

            const worker = target.closest('.worker');
            if (!worker || worker.classList.contains('inactive')) return;

            const workerId = worker.dataset.id;
            const workerPlayer = parseInt(worker.dataset.player);
            if (workerPlayer !== gameState.currentPlayer) return;

            e.preventDefault();

            const rect = worker.getBoundingClientRect();
            dragState.dragOffsetX = touch.clientX - rect.left;
            dragState.dragOffsetY = touch.clientY - rect.top;

            dragState.isDragging = true;
            dragState.originalWorker = worker;
            dragState.workerId = workerId;

            createDragClone(worker, touch.clientX, touch.clientY);
            worker.classList.add('worker-ghost');
        }

        // Create visual clone of dragged worker
        function createDragClone(originalWorker, x, y) {
            const clone = originalWorker.cloneNode(true);
            const rect = originalWorker.getBoundingClientRect();

            clone.style.position = 'fixed';
            clone.style.zIndex = '1000';
            clone.style.pointerEvents = 'none';
            clone.style.width = rect.width + 'px';
            clone.style.height = rect.height + 'px';
            clone.style.left = (x - dragState.dragOffsetX) + 'px';
            clone.style.top = (y - dragState.dragOffsetY) + 'px';
            clone.style.transform = 'none';
            clone.style.transition = 'none';
            clone.style.opacity = '0.9';
            clone.classList.remove('worker-ghost', 'inactive', 'elevated');
            clone.classList.add('dragging');

            dragState.dragClone = clone;
            document.body.appendChild(clone);
        }

        // Handle drag move
        function handleDragMove(e) {
            if (!dragState.isDragging || !dragState.dragClone) return;

            e.preventDefault();

            const touch = e.type.startsWith('touch') ? e.touches[0] : e;

            dragState.dragClone.style.left = (touch.clientX - dragState.dragOffsetX) + 'px';
            dragState.dragClone.style.top = (touch.clientY - dragState.dragOffsetY) + 'px';

            updateDropZoneHighlight(touch.clientX, touch.clientY);
        }

        // Update drop zone highlighting
        function updateDropZoneHighlight(x, y) {
            const allCells = document.querySelectorAll('.grid-cell');
            allCells.forEach(cell => cell.classList.remove('valid-move'));

            const elementBelow = document.elementFromPoint(x, y);
            const cell = elementBelow?.closest('.grid-cell');

            if (!cell) return;

            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            const worker = findWorker(dragState.workerId);
            const validMoves = getValidMoves(worker);

            if (validMoves.some(m => m.row === row && m.col === col)) {
                cell.classList.add('valid-move');
            }
        }

        // Handle drag end
        function handleDragEnd(e) {
            if (!dragState.isDragging) return;

            e.preventDefault();

            const touch = e.type === 'touchend' ? e.changedTouches[0] : e;
            const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);
            const cell = dropTarget?.closest('.grid-cell');

            if (cell) {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const worker = findWorker(dragState.workerId);
                const validMoves = getValidMoves(worker);

                if (validMoves.some(m => m.row === row && m.col === col)) {
                    moveWorker(dragState.workerId, row, col);
                }
            }

            // Clean up drag state
            if (dragState.dragClone) {
                dragState.dragClone.remove();
                dragState.dragClone = null;
            }

            if (dragState.originalWorker) {
                dragState.originalWorker.classList.remove('worker-ghost');
            }

            document.querySelectorAll('.grid-cell').forEach(c => {
                c.classList.remove('valid-move');
            });

            dragState.isDragging = false;
            dragState.originalWorker = null;
            dragState.workerId = null;

            renderGame();
        }

        // Find worker by ID
        function findWorker(id) {
            const allWorkers = [
                ...gameState.workers.player1,
                ...gameState.workers.player2
            ];
            return allWorkers.find(w => w.id === id);
        }

        // Get valid moves for a worker
        function getValidMoves(worker) {
            const moves = [];
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];

            const currentHeight = gameState.board[worker.row][worker.col];

            directions.forEach(([dr, dc]) => {
                const newRow = worker.row + dr;
                const newCol = worker.col + dc;

                if (newRow >= 0 && newRow < GRID_SIZE &&
                    newCol >= 0 && newCol < GRID_SIZE) {

                    const targetHeight = gameState.board[newRow][newCol];

                    // Can't move to a dome
                    if (targetHeight === 4) return;

                    // Can't move up more than 1 level
                    if (targetHeight > currentHeight + 1) return;

                    // Check if position is occupied
                    const occupied = isOccupied(newRow, newCol);
                    if (!occupied) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            });

            return moves;
        }

        // Check if a position is occupied by a worker
        function isOccupied(row, col) {
            const allWorkers = [
                ...gameState.workers.player1,
                ...gameState.workers.player2
            ];
            return allWorkers.some(w => w.row === row && w.col === col);
        }

        // Move worker
        function moveWorker(workerId, row, col) {
            const worker = findWorker(workerId);
            const oldHeight = gameState.board[worker.row][worker.col];
            const newHeight = gameState.board[row][col];

            worker.row = row;
            worker.col = col;

            gameState.selectedWorker = worker;
            gameState.gamePhase = 'build';

            // Check for win condition (reached level 3)
            if (newHeight === 3 && oldHeight !== 3) {
                gameState.gameOver = true;
                gameState.winner = gameState.currentPlayer;
                renderGame();
                setTimeout(() => showVictory(), 500);
                return;
            }

            renderGame();
            updateStatus();
        }

        // Get valid build positions
        function getValidBuilds(worker) {
            const builds = [];
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];

            directions.forEach(([dr, dc]) => {
                const newRow = worker.row + dr;
                const newCol = worker.col + dc;

                if (newRow >= 0 && newRow < GRID_SIZE &&
                    newCol >= 0 && newCol < GRID_SIZE) {

                    const targetHeight = gameState.board[newRow][newCol];

                    // Can't build on a dome or beyond level 3
                    if (targetHeight >= 4) return;

                    // Check if position is occupied
                    const occupied = isOccupied(newRow, newCol);
                    if (!occupied) {
                        builds.push({ row: newRow, col: newCol });
                    }
                }
            });

            return builds;
        }

        // Handle cell click
        function handleCellClick(row, col) {
            if (gameState.gameOver) return;

            // Setup phase - place workers
            if (gameState.gamePhase === 'setup') {
                // Check if cell is already occupied
                if (isOccupied(row, col)) return;

                // Place worker based on setup phase
                if (gameState.setupPhase === 'player1-worker1') {
                    gameState.workers.player1.push({ row, col, id: 'p1w1' });
                    gameState.setupPhase = 'player1-worker2';
                } else if (gameState.setupPhase === 'player1-worker2') {
                    gameState.workers.player1.push({ row, col, id: 'p1w2' });
                    gameState.setupPhase = 'player2-worker1';
                    gameState.currentPlayer = 2;
                } else if (gameState.setupPhase === 'player2-worker1') {
                    gameState.workers.player2.push({ row, col, id: 'p2w1' });
                    gameState.setupPhase = 'player2-worker2';
                } else if (gameState.setupPhase === 'player2-worker2') {
                    gameState.workers.player2.push({ row, col, id: 'p2w2' });
                    // Setup complete, start game
                    gameState.gamePhase = 'move';
                    gameState.currentPlayer = 1;
                    gameState.setupPhase = null;
                }

                renderGame();
                updateStatus();
                return;
            }

            // Build phase
            if (gameState.gamePhase === 'build' && gameState.selectedWorker) {
                const validBuilds = getValidBuilds(gameState.selectedWorker);

                if (validBuilds.some(b => b.row === row && b.col === col)) {
                    // Build
                    gameState.board[row][col]++;

                    // Switch to next player
                    gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
                    gameState.gamePhase = 'move';
                    gameState.selectedWorker = null;

                    // Check if new player can move
                    const currentWorkers = gameState.currentPlayer === 1 ?
                        gameState.workers.player1 : gameState.workers.player2;

                    const hasValidMoves = currentWorkers.some(w => getValidMoves(w).length > 0);

                    if (!hasValidMoves) {
                        gameState.gameOver = true;
                        gameState.winner = gameState.currentPlayer === 1 ? 2 : 1;
                        renderGame();
                        setTimeout(() => showVictory(), 500);
                        return;
                    }

                    renderGame();
                    updateStatus();
                }
            }
        }

        // Update status message
        function updateStatus() {
            const status1 = document.getElementById('player-1-status');
            const status2 = document.getElementById('player-2-status');

            status1.textContent = '';
            status2.textContent = '';

            if (gameState.gameOver) {
                const statusEl = gameState.winner === 1 ? status1 : status2;
                statusEl.textContent = 'Winner!';
            } else if (gameState.gamePhase === 'setup') {
                const statusEl = gameState.currentPlayer === 1 ? status1 : status2;
                const workerNum = gameState.setupPhase.includes('worker1') ? '1st' : '2nd';
                statusEl.textContent = `Place ${workerNum} worker`;
            } else {
                const statusEl = gameState.currentPlayer === 1 ? status1 : status2;

                if (gameState.gamePhase === 'move') {
                    statusEl.textContent = 'Move a worker';
                } else {
                    statusEl.textContent = 'Build adjacent';
                }
            }
        }

        // Show victory overlay
        function showVictory() {
            const overlay = document.createElement('div');
            overlay.className = 'victory-overlay';

            const winnerName = gameState.winner === 1 ? 'Player 1' : 'Player 2';
            const winnerColor = gameState.winner === 1 ? gameState.player1Color : gameState.player2Color;

            overlay.innerHTML = `
                <div class="victory-text">${winnerName} Wins!</div>
                <div class="victory-subtext">${winnerColor.toUpperCase()} Victorious!</div>
            `;

            document.body.appendChild(overlay);
            createConfetti();

            overlay.addEventListener('click', () => {
                overlay.remove();
                document.querySelectorAll('.confetti').forEach(c => c.remove());
            });
        }

        // Create confetti effect
        function createConfetti() {
            const colors = ['#FFD700', '#FFA500', '#FF6347', '#FF1493', '#00CED1', '#32CD32'];
            const confettiCount = 100;

            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.setProperty('--drift-x', (Math.random() - 0.5) * 200 + 'px');
                confetti.style.animationDelay = Math.random() * 0.5 + 's';
                document.body.appendChild(confetti);

                setTimeout(() => confetti.remove(), 3500);
            }
        }

        // Button event listeners
        document.getElementById('new-game').addEventListener('click', () => {
            document.querySelectorAll('.victory-overlay').forEach(el => el.remove());
            document.querySelectorAll('.confetti').forEach(el => el.remove());
            initGame();
        });

        document.getElementById('back-button').addEventListener('click', () => {
            window.location.href = 'https://kkollsga.github.io/tesla/';
        });

        // Scale game board to fit screen
        function scaleGameBoard() {
            const gameBoard = document.querySelector('.game-board');
            const gameContainer = document.querySelector('.game-container');

            if (!gameBoard || !gameContainer) return;

            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            const paddingPercent = 0.02;
            const paddingX = viewportWidth * paddingPercent;
            const paddingY = viewportHeight * paddingPercent;

            const availableWidth = viewportWidth - (paddingX * 2);
            const availableHeight = viewportHeight - (paddingY * 2);

            gameBoard.style.transform = 'scale(1)';
            gameBoard.style.position = 'relative';

            const baseWidth = gameContainer.offsetWidth;
            const baseHeight = gameContainer.offsetHeight;

            const scaleX = availableWidth / baseWidth;
            const scaleY = availableHeight / baseHeight;
            const scale = Math.min(scaleX, scaleY);

            currentBoardScale = scale;

            gameBoard.style.transform = `scale(${scale})`;

            const scaledWidth = baseWidth * scale;
            const scaledHeight = baseHeight * scale;

            const leftOffset = (viewportWidth - scaledWidth) / 2;
            const topOffset = (viewportHeight - scaledHeight) / 2;

            gameBoard.style.position = 'absolute';
            gameBoard.style.left = leftOffset + 'px';
            gameBoard.style.top = topOffset + 'px';
        }

        const debouncedScaleGameBoard = debounce(scaleGameBoard, 150);

        window.addEventListener('load', () => {
            initGame();
            scaleGameBoard();
            setTimeout(scaleGameBoard, 100);
        });

        window.addEventListener('resize', debouncedScaleGameBoard);

        // Info button functionality
        document.getElementById('info-button').addEventListener('click', (e) => {
            e.stopPropagation();
            showGameInfo();
        });

        function showGameInfo() {
            const overlay = document.createElement('div');
            overlay.className = 'info-overlay';

            overlay.innerHTML = `
                <div class="info-panel">
                    <h2>How to Play Santorini</h2>

                    <h3>Objective</h3>
                    <p>Be the first player to move one of your workers to the third level of a building!</p>

                    <h3>Game Setup</h3>
                    <p>The game starts with an empty 5x5 board. Players are randomly assigned colors (blue or orange).</p>
                    <ul>
                        <li>Player 1 places their first worker by clicking any space</li>
                        <li>Player 1 places their second worker</li>
                        <li>Player 2 places their first worker</li>
                        <li>Player 2 places their second worker</li>
                        <li>Then normal gameplay begins with Player 1</li>
                    </ul>

                    <h3>How to Play</h3>
                    <p>On your turn, you must complete two actions:</p>
                    <ul>
                        <li><strong>Move:</strong> Drag one of your workers to an adjacent space (horizontal, vertical, or diagonal). You can move up one level, stay on the same level, or move down any number of levels. You cannot move up more than one level or onto a dome.</li>
                        <li><strong>Build:</strong> After moving, click an adjacent space to build. Buildings have 4 levels (shown as layered white squares, with blue domes at level 4). You build one level at a time on any adjacent unoccupied space.</li>
                    </ul>

                    <h3>Winning</h3>
                    <p>You win instantly when one of your workers moves from level 2 to level 3!</p>
                    <p>You also win if your opponent cannot make a legal move on their turn.</p>

                    <h3>Strategy Tips</h3>
                    <ul>
                        <li>Try to build strategically to create paths to level 3</li>
                        <li>Block your opponent by building domes (level 4) on key spaces</li>
                        <li>Keep both workers mobile - don't let them get trapped</li>
                        <li>Control the center of the board for more options</li>
                        <li>Watch for your opponent's threats - they might be one move from victory!</li>
                    </ul>
                </div>
            `;

            document.body.appendChild(overlay);

            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                }
            });

            overlay.querySelector('.info-panel').addEventListener('click', (e) => {
                e.stopPropagation();
            });
        }
    </script>
</body>
</html>
